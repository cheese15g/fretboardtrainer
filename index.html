<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>지판 암기 트레이닝</title>
<style>
  :root { --border:4px solid #000; --gap:8px; --bg:#fff; --font: 'Malgun Gothic', Arial, sans-serif; }
  body { margin:20px; font-family:var(--font); display:flex; justify-content:center; }
  .frame {
    width:360px; border:var(--border); padding:10px; box-sizing:border-box;
    display:flex; flex-direction:column; gap:8px;
  }
  .top-row { display:flex; gap:6px; justify-content:space-between; }
  .string-block { flex:1; border:3px solid #000; height:44px; display:flex; align-items:center; justify-content:center; font-weight:700; background:#fff; user-select:none; }
  .controls-row { display:flex; gap:6px; }
  .control { flex:1; border:3px solid #000; height:44px; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; background:#fff; }
  .control.on { background:#d0f0d0; } /* 토글 표시(단순 색) */
  .big-roll { border:3px solid #000; height:74px; display:flex; align-items:center; justify-content:center; font-size:20px; cursor:pointer; user-select:none; }
  .option-list { display:flex; flex-direction:column; gap:6px; }
  .option-btn { border:3px solid #000; height:36px; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; background:#fff; }
  .strings-area { display:grid; grid-template-columns:repeat(6,1fr); gap:6px; margin-top:8px; }
  .target { border:3px solid #000; height:56px; display:flex; align-items:center; justify-content:center; background:#fff; font-weight:700; }
  .target.correct { background:#9ae69a; } /* 초록 고정 */
  .target.wrong { background:#ff9a9a; } /* 빨강 잠깐 */
  .placeholder { height:36px; border:3px solid #000; display:flex; align-items:center; justify-content:center; }
  .status { margin-top:8px; height:120px; border:3px solid #000; padding:6px; box-sizing:border-box; overflow:auto; }
  .top-note-text { font-size:14px; }
  .timer { margin-left:8px; font-weight:700; }
  .device-select { display:flex; gap:6px; align-items:center; }
  .badge { padding:4px 6px; border:2px solid #000; }
</style>
</head>
<body>
  <div class="frame">
    <!-- 상단 6개 블럭 -->
    <div class="top-row" id="topRow">
      <div class="string-block" data-idx="0">E</div>
      <div class="string-block" data-idx="1">A</div>
      <div class="string-block" data-idx="2">D</div>
      <div class="string-block" data-idx="3">G</div>
      <div class="string-block" data-idx="4">B</div>
      <div class="string-block" data-idx="5">E</div>
    </div>

    <!-- 음표시 / 시간표시 영역 (고정 자리) -->
    <div style="display:flex;gap:8px;">
      <div class="control" id="noteDisplayToggle">음표시</div>
      <div class="control" id="timeDisplayArea">시간표시 <span class="timer" id="timerText">-</span></div>
    </div>

    <!-- Roll 버튼 -->
    <div class="big-roll" id="rollBtn">roll</div>

    <!-- 옵션들 (고정 자리) -->
    <div class="option-list" style="width:100%;">
      <div class="option-btn" id="noDupBtn">중복금지</div>
      <div class="option-btn" id="accidentalBtn">플랫 샵표시</div>
      <div class="option-btn" id="showNoteBtn">음표시 (검출음)</div>
      <div class="option-btn" id="autoRollBtn">오토롤</div>
    </div>

    <!-- 장치 선택 및 상태 -->
    <div style="display:flex;align-items:center;gap:8px;margin-top:6px;">
      <div class="device-select">
        <label for="deviceSelect">입력장치</label>
        <select id="deviceSelect"></select>
      </div>
      <div class="badge" id="detectedNote">-</div>
    </div>

    <!-- 고정된 6개 타겟 블럭 영역 -->
    <div class="strings-area" id="targetsArea">
      <div class="target" data-pos="0">E</div>
      <div class="target" data-pos="1">A</div>
      <div class="target" data-pos="2">D</div>
      <div class="target" data-pos="3">G</div>
      <div class="target" data-pos="4">B</div>
      <div class="target" data-pos="5">E</div>
    </div>

    <!-- 상태박스 -->
    <div class="status" id="logArea">
      상태: 준비됨.
      <div style="margin-top:8px;">주의: 마이크/오인페 환경에 따라 음 검출 정확도가 달라질 수 있습니다. 확실하지 않음.</div>
    </div>
  </div>

<script>
/*
  지판 암기 트레이닝 웹앱
  - 파일로 저장한 뒤 브라우저에서 열면 동작
  - 마이크/오디오 입력 권한 필요
  - 구현 방식: WebAudio + 오토상관 피치검출
*/

/* ---------- 설정 및 전역 ---------- */
const NATURAL_NOTES = ['C','D','E','F','G','A','B'];
const SEMI_NOTES_SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const SEMI_NOTES_FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
// 음계 표준 A4 = 440Hz
const A4_FREQ = 440;
const NOTE_LOG = []; // 로그
let audioCtx=null, analyser=null, sourceNode=null, mediaStream=null;
let deviceId = null;
let rafId = null;
let bufferLen = 2048;
let isDetecting = false;

/* UI 요소 */
const topRow = document.getElementById('topRow');
const rollBtn = document.getElementById('rollBtn');
const noDupBtn = document.getElementById('noDupBtn');
const accidentalBtn = document.getElementById('accidentalBtn');
const showNoteBtn = document.getElementById('showNoteBtn');
const autoRollBtn = document.getElementById('autoRollBtn');
const deviceSelect = document.getElementById('deviceSelect');
const detectedNoteBadge = document.getElementById('detectedNote');
const targetsArea = document.getElementById('targetsArea');
const timerText = document.getElementById('timerText');
const logArea = document.getElementById('logArea');

let options = {
  noDup: false,
  accidental: false,
  showNote: false,
  autoRoll: false
};

let currentTargets = ['E','A','D','G','B','E']; // 표시되는 6음 (문자열)
let targetStates = [false,false,false,false,false,false]; // 정답 고정 유무
let currentIndex = 0; // 지금 맞춰야 할 블럭 인덱스
let timer = { running:false, start:0, elapsed:0, intervalId:null, enabled:true };

/* ---------- 유틸: 주파수 -> 음으로 매핑 ---------- */
function freqToNote(freq, useAccidental=false) {
  if (!freq || freq<=0) return null;
  // MIDI 노트 번호 계산: n = 69 + 12*log2(freq/440)
  const n = 69 + 12 * Math.log2(freq / A4_FREQ);
  const roundN = Math.round(n);
  const noteIndex = (roundN + 120) % 12; // 0..11
  const octave = Math.floor(roundN / 12) - 1;
  const name = useAccidental ? SEMI_NOTES_SHARP[noteIndex] : SEMI_NOTES_SHARP[noteIndex]; // 기본은 샵 표기
  return { name, octave, midi: roundN, semitone: noteIndex };
}

// natural note comparison: C D E F G A B regardless of octave; map semitone->natural
function semitoneToNatural(semi) {
  // semi 0..11 where 0=C
  const map = {
    0:'C',1:'C',2:'D',3:'D',4:'E',5:'F',6:'F',7:'G',8:'G',9:'A',10:'A',11:'B'
  };
  return map[semi%12];
}

function semitoneToDisplay(semi, useAccidental) {
  if (useAccidental) return SEMI_NOTES_SHARP[semi%12];
  // If no accidental allowed, show natural: choose proper natural among semitone
  return semitoneToNatural(semi);
}

/* ---------- 랜덤 타겟 생성 ---------- */
function generateTargets() {
  // 옵션에 따라 후보군 설정
  let candidates = [];
  if (options.accidental) {
    // 12 semitones, represent as note strings C..B with # where applicable
    candidates = SEMI_NOTES_SHARP.slice(); // length 12
  } else {
    candidates = NATURAL_NOTES.slice(); // 7 naturals
  }

  // when noDup true, ensure uniqueness across 6 picks (if candidates <6, allow duplicates and mark 확실하지 않음)
  let picks = [];
  if (options.noDup && candidates.length >= 6) {
    let pool = candidates.slice();
    for (let i=0;i<6;i++) {
      const idx = Math.floor(Math.random()*pool.length);
      picks.push(pool[idx]);
      pool.splice(idx,1);
    }
  } else {
    // allow duplicates
    for (let i=0;i<6;i++) {
      const idx = Math.floor(Math.random()*candidates.length);
      picks.push(candidates[idx]);
    }
    if (options.noDup && candidates.length < 6) {
      // 후보가 6미만인데 noDup 선택된 경우, 불충분함 알림
      appendLog('확실하지 않음: 후보음이 6개 미만이므로 중복금지 옵션을 지킬 수 없습니다.');
    }
  }
  currentTargets = picks;
  // reflect top row and target blocks
  const topBlocks = topRow.querySelectorAll('.string-block');
  topBlocks.forEach((el,i) => el.textContent = currentTargets[i]);
  const tblocks = targetsArea.querySelectorAll('.target');
  tblocks.forEach((el,i)=> { el.textContent = currentTargets[i]; el.classList.remove('correct','wrong'); });
  targetStates = [false,false,false,false,false,false];
  currentIndex = 0;
  updateTargetHighlight();
}

/* ---------- UI 헬퍼 ---------- */
function appendLog(msg) {
  const d = document.createElement('div');
  d.textContent = `${new Date().toLocaleTimeString()} - ${msg}`;
  logArea.prepend(d);
}
function updateOptionUI() {
  noDupBtn.classList.toggle('on', options.noDup);
  accidentalBtn.classList.toggle('on', options.accidental);
  showNoteBtn.classList.toggle('on', options.showNote);
  autoRollBtn.classList.toggle('on', options.autoRoll);
  // 시간표시 영역 고정 자리; 옵션 선택될 때 표시. (요구사항 6: 자리는 비워두거나 '-' 표기)
  // 시간표시 자체는 timerText에서 조절.
}
function updateTargetHighlight() {
  const tblocks = targetsArea.querySelectorAll('.target');
  tblocks.forEach((el,i)=>{
    el.style.outline = 'none';
    if (targetStates[i]) { el.classList.add('correct'); el.classList.remove('wrong'); }
    else { el.classList.remove('correct','wrong'); }
    if (i === currentIndex && !targetStates[i]) {
      el.style.boxShadow = 'inset 0 0 0 3px rgba(0,0,0,0.2)';
    } else {
      el.style.boxShadow = 'none';
    }
  });
}

/* ---------- 타이머 로직 (0.1s 단위) ---------- */
function startTimerIfEnabled(triggeredByButton=false) {
  // 요구사항 5-1: 버튼을 누를시 시간 표시기능을 시용하지 않음 => 즉, roll 버튼이벤트로 시작된 경우 타이머 비활성
  if (triggeredByButton) {
    timer.enabled = false;
    timerText.textContent = '-';
    appendLog('롤 버튼으로 시작되어 시간표시 비활성화됨.');
    return;
  }
  timer.enabled = true;
  timer.running = true;
  timer.start = performance.now();
  timer.elapsed = 0;
  timerText.textContent = '0.0s';
  if (timer.intervalId) clearInterval(timer.intervalId);
  timer.intervalId = setInterval(()=>{
    timer.elapsed = performance.now() - timer.start;
    timerText.textContent = (timer.elapsed/1000).toFixed(1) + 's';
  },100);
}

function stopTimer() {
  if (timer.intervalId) { clearInterval(timer.intervalId); timer.intervalId = null; }
  timer.running = false;
  if (timer.enabled) {
    // leave the elapsed shown
  } else {
    timerText.textContent = '-';
  }
}

/* ---------- 오디오 처리 및 피치 검출 (오토상관) ---------- */
function setupAudioInput(selectedDeviceId=null) {
  stopDetecting();
  if (audioCtx) {
    try { audioCtx.close(); } catch(e) {}
  }
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const constraints = {
    audio: {
      deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
      channelCount:1,
      sampleRate: audioCtx.sampleRate
    },
    video:false
  };
  navigator.mediaDevices.getUserMedia(constraints).then(stream=>{
    mediaStream = stream;
    sourceNode = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    sourceNode.connect(analyser);
    isDetecting = true;
    appendLog('오디오 입력 연결됨. 샘플레이트: ' + audioCtx.sampleRate);
    detectPitchLoop();
  }).catch(err=>{
    appendLog('마이크/오디오 접근 오류: ' + err.message);
  });
}

function stopDetecting() {
  isDetecting = false;
  if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
  if (mediaStream) {
    mediaStream.getTracks().forEach(t=>t.stop());
    mediaStream = null;
  }
}

/* 오토상관 기반 피치 검출 (간단형) */
function autoCorrelate(buf, sampleRate) {
  // from Chris Wilson example (modified)
  let SIZE = buf.length;
  let rms = 0;
  for (let i=0;i<SIZE;i++) {
    let val = buf[i];
    rms += val*val;
  }
  rms = Math.sqrt(rms/SIZE);
  if (rms < 0.01) return -1; // 너무 약함

  let r1 = 0, r2 = SIZE - 1, thres = 0.2;
  for (let i=0;i<SIZE/2;i++) {
    if (Math.abs(buf[i]) < thres) { r1 = i; break; }
  }
  for (let i=1;i<SIZE/2;i++) {
    if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
  }

  buf = buf.slice(r1, r2);
  SIZE = buf.length;

  let c = new Array(SIZE).fill(0);
  for (let i=0;i<SIZE;i++) {
    for (let j=0;j<SIZE - i;j++) {
      c[i] = c[i] + buf[j]*buf[j+i];
    }
  }

  let d = 0;
  while (c[d] > c[d+1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i=d; i<SIZE; i++) {
    if (c[i] > maxval) {
      maxval = c[i];
      maxpos = i;
    }
  }
  let T0 = maxpos;

  if (!T0) return -1;
  // Parabolic interpolation
  let x1 = c[T0-1], x2 = c[T0], x3 = c[T0+1];
  let a = (x1 + x3 - 2*x2)/2;
  let b = (x3 - x1)/2;
  if (a) T0 = T0 - b/(2*a);

  const freq = sampleRate / T0;
  return freq;
}

function detectPitchLoop() {
  const buf = new Float32Array(analyser.fftSize);
  function loop() {
    analyser.getFloatTimeDomainData(buf);
    const freq = autoCorrelate(buf, audioCtx.sampleRate);
    if (freq !== -1 && freq !== null) {
      const note = freqToNote(freq, true);
      if (note) {
        const display = semitoneToDisplay(note.semitone, options.accidental);
        // detected note badge
        detectedNoteBadge.textContent = display + note.octave;
        if (options.showNote) document.querySelector('.badge')?.classList.add(''); // no-op to show badge exists
        // handle comparison to current target
        handleDetected(display);
      }
    } else {
      detectedNoteBadge.textContent = '-';
    }
    if (isDetecting) rafId = requestAnimationFrame(loop);
  }
  loop();
}

/* ---------- 검출된 음 처리: 타겟과 비교 ---------- */
function handleDetected(detectedDisplay) {
  if (!detectedDisplay) return;
  if (currentIndex >= 6) return;
  const target = currentTargets[currentIndex];
  // 비교 로직: 옵션에 따라 비교 방법이 달라짐.
  // - if accidental option is false, targets are natural; detectedDisplay may be 'C#' etc.
  // we'll compare only by letter if options.accidental==false (i.e., ignore #/b)
  let match = false;
  if (options.accidental) {
    // allow enharmonic equivalence: map both to semitone index and compare
    const detSemi = SEMI_NOTES_SHARP.indexOf(detectedDisplay);
    const tgtSemi = SEMI_NOTES_SHARP.indexOf(target) !== -1 ? SEMI_NOTES_SHARP.indexOf(target) : SEMI_NOTES_SHARP.indexOf(target+''); 
    match = detSemi === tgtSemi;
  } else {
    // compare only natural letters ignoring accidental
    const detNatural = detectedDisplay[0]; // first char is letter
    match = detNatural === target[0];
  }

  // update visual feedback
  const tblocks = targetsArea.querySelectorAll('.target');
  const block = tblocks[currentIndex];
  if (match) {
    block.classList.add('correct');
    block.classList.remove('wrong');
    targetStates[currentIndex] = true;
    appendLog(`정답: ${detectedDisplay} == ${currentTargets[currentIndex]}`);
    // 멈출 때까지 색 고정, 다음 인덱스로
    currentIndex++;
    updateTargetHighlight();
    // 모든 음을 맞춘 경우 처리
    if (currentIndex >= 6) {
      stopTimer();
      appendLog('모든 음을 맞춤.');
      if (options.autoRoll) {
        // 자동으로 새로운 랜덤 세트 생성 (타이머는 자동으로 동작하도록 startTimerIfEnabled(false) 호출)
        setTimeout(()=> {
          generateTargets();
          startTimerIfEnabled(false);
          appendLog('오토롤로 새 세트 생성됨.');
        },400);
      }
    }
  } else {
    // 틀렸을 때 빨갛게 잠깐 변했다가 돌아옴, 다음으로 넘어가지 않음
    block.classList.add('wrong');
    setTimeout(()=> { if (!targetStates[currentIndex]) block.classList.remove('wrong'); },500);
    appendLog(`오답: ${detectedDisplay} != ${currentTargets[currentIndex]}`);
  }
}

/* ---------- 이벤트 바인딩 ---------- */
noDupBtn.addEventListener('click', ()=>{
  options.noDup = !options.noDup;
  updateOptionUI();
  appendLog('중복금지 ' + (options.noDup ? 'ON' : 'OFF'));
});

accidentalBtn.addEventListener('click', ()=>{
  options.accidental = !options.accidental;
  updateOptionUI();
  appendLog('플랫 샵표시 ' + (options.accidental ? 'ON' : 'OFF'));
});

showNoteBtn.addEventListener('click', ()=>{
  options.showNote = !options.showNote;
  updateOptionUI();
  appendLog('음표시 ' + (options.showNote ? 'ON' : 'OFF'));
});

autoRollBtn.addEventListener('click', ()=>{
  options.autoRoll = !options.autoRoll;
  updateOptionUI();
  appendLog('오토롤 ' + (options.autoRoll ? 'ON' : 'OFF'));
});

rollBtn.addEventListener('click', ()=>{
  generateTargets();
  // roll 버튼으로 시작되었으므로 타이머 비활성(요구사항 5-1)
  startTimerIfEnabled(true);
});

/* 타겟 블럭 클릭(테스트용) */
targetsArea.addEventListener('click', (ev)=>{
  const t = ev.target.closest('.target');
  if (!t) return;
  // 클릭 시 해당 인덱스로 이동 (편의 기능 — 고정 레이아웃 유지)
  const idx = Number(t.dataset.pos);
  currentIndex = idx;
  updateTargetHighlight();
});

/* ---------- 장치 목록 불러오기 및 선택 ---------- */
async function populateDevices() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(d=>d.kind === 'audioinput');
    deviceSelect.innerHTML = '';
    audioInputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || 'Input ' + (deviceSelect.length+1);
      deviceSelect.appendChild(opt);
    });
    if (audioInputs.length>0) {
      deviceSelect.value = audioInputs[0].deviceId;
      deviceId = audioInputs[0].deviceId;
      setupAudioInput(deviceId);
    } else {
      appendLog('오디오 입력 장치가 감지되지 않음.');
    }
  } catch(err) {
    appendLog('장치 조회 오류: ' + err.message);
  }
}

deviceSelect.addEventListener('change', (e)=>{
  deviceId = e.target.value;
  if (deviceId) setupAudioInput(deviceId);
});

/* ---------- 초기화 ---------- */
(function init() {
  updateOptionUI();
  // 초기 타겟 세트는 E A D G B E (요구사항)
  currentTargets = ['E','A','D','G','B','E'];
  const tblocks = targetsArea.querySelectorAll('.target');
  tblocks.forEach((el,i)=> el.textContent = currentTargets[i]);
  // 장치 목록 불러오기 (권한 요청 필요)
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia({ audio:true }).then(stream=>{
      // 권한 요청 성공시 장치 목록 로드
      stream.getTracks().forEach(t=>t.stop());
      populateDevices();
    }).catch(err=>{
      appendLog('오디오 권한 필요: ' + err.message);
    });
  } else {
    appendLog('getUserMedia 미지원 브라우저: 확실하지 않음.');
  }
})();
</script>
</body>
</html>
