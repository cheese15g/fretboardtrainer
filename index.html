<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>기타 음 인식</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #111;
      color: #fff;
      font-family: sans-serif;
    }
    #correctNote {
      font-size: 5em;
      font-weight: bold;
      margin-bottom: 20px;
    }
    #detectedNote {
      font-size: 2em;
      opacity: 0.7;
    }
    #overlay {
      position: absolute;
      top:0; left:0; right:0; bottom:0;
      background:#000;
      display:flex;
      justify-content:center;
      align-items:center;
      color:#fff;
      font-size:2em;
    }
  </style>
</head>
<body>
  <div id="overlay">탭하여 시작</div>
  <div id="correctNote">--</div>
  <div id="detectedNote">--</div>

  <script>
    const noteStrings = ["C", "C#", "D", "D#", "E", "F", 
                         "F#", "G", "G#", "A", "A#", "B"];

    let audioContext, analyser, dataArray;
    let detectedNoteElem = document.getElementById("detectedNote");
    let correctNoteElem = document.getElementById("correctNote");
    let overlay = document.getElementById("overlay");

    // 랜덤 음 생성
    function getRandomNote() {
      return noteStrings[Math.floor(Math.random() * noteStrings.length)];
    }

    // 주파수 → MIDI → 음 이름
    function freqToNote(freq) {
      const A4 = 440;
      const noteNumber = 12 * (Math.log(freq / A4) / Math.log(2)) + 69;
      return Math.round(noteNumber);
    }
    function noteToString(note) {
      return noteStrings[(note % 12 + 12) % 12];
    }

    // pitch detection (autocorrelation)
    function autoCorrelate(buf, sampleRate) {
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        let val = buf[i] / 128 - 1;
        rms += val * val;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) {
        if (Math.abs(buf[i] - 128) / 128 > thres) { r1 = i; break; }
      }
      for (let i = 1; i < SIZE / 2; i++) {
        if (Math.abs(buf[SIZE - i] - 128) / 128 > thres) { r2 = SIZE - i; break; }
      }

      buf = buf.slice(r1, r2);
      SIZE = buf.length;

      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++)
        for (let j = 0; j < SIZE - i; j++)
          c[i] = c[i] + (buf[j] - 128) * (buf[j+i] - 128);

      let d = 0; while (c[d] > c[d+1]) d++;
      let maxval=-1, maxpos=-1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;

      return sampleRate / T0;
    }

    let lastDetectedNote = null;
    let noteStableSince = 0;
    let correctNote = "--";

    // *** 여기서 정답으로 인정할 최소 유지 시간 설정 (기본: 40초) ***
    const CORRECT_NOTE_HOLD_TIME = 40000; // 40초 (ms)

    function updatePitch() {
      analyser.getByteTimeDomainData(dataArray);
      let pitch = autoCorrelate(dataArray, audioContext.sampleRate);
      if (pitch !== -1) {
        let midiNote = freqToNote(pitch);
        let noteName = noteToString(midiNote);

        // 실시간 검출 음 표시
        detectedNoteElem.textContent = noteName;

        // 정답 판정 로직
        if (noteName === lastDetectedNote) {
          if (Date.now() - noteStableSince > CORRECT_NOTE_HOLD_TIME && noteName !== correctNote) {
            // 랜덤 음 생성 (단, 현재 음과 옥타브 관계여도 같은 이름이면 다시 뽑기)
            let newNote;
            do {
              newNote = getRandomNote();
            } while (newNote === noteName);
            correctNote = newNote;
            correctNoteElem.textContent = correctNote;
          }
        } else {
          lastDetectedNote = noteName;
          noteStableSince = Date.now();
        }
      }
      requestAnimationFrame(updatePitch);
    }

    overlay.onclick = async () => {
      overlay.style.display = "none";
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      dataArray = new Uint8Array(analyser.fftSize);
      source.connect(analyser);
      updatePitch();
    }
  </script>
</body>
</html>
