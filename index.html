<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>기타 음 검출 연습</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    background: #111;
    color: #fff;
    font-family: sans-serif;
  }
  #randomNote {
    font-size: 120px;
    font-weight: bold;
    margin-bottom: 40px;
  }
  #detectedNote {
    font-size: 28px;
    background: #333;
    padding: 10px 20px;
    border-radius: 12px;
  }
</style>
</head>
<body>
  <div id="randomNote">—</div>
  <div id="detectedNote">—</div>

<script>
const noteStrings = ["C", "C#", "D", "D#", "E", "F", 
                     "F#", "G", "G#", "A", "A#", "B"];

let audioCtx, analyser, buf, sourceNode;
let randomNoteElem = document.getElementById("randomNote");
let detectedNoteElem = document.getElementById("detectedNote");

function noteFromPitch(frequency) {
  let noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
  return Math.round(noteNum) + 69;
}

function autoCorrelate(buf, sampleRate) {
  let SIZE = buf.length;
  let rms = 0;

  for (let i = 0; i < SIZE; i++) {
    let val = buf[i];
    rms += val * val;
  }
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.0008) return -1; // 노이즈 게이트

  let r1 = 0, r2 = SIZE - 1, thres = 0.2;
  for (let i = 0; i < SIZE / 2; i++) {
    if (Math.abs(buf[i]) < thres) { r1 = i; break; }
  }
  for (let i = 1; i < SIZE / 2; i++) {
    if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
  }

  buf = buf.slice(r1, r2);
  SIZE = buf.length;

  let c = new Array(SIZE).fill(0);
  for (let i = 0; i < SIZE; i++) {
    for (let j = 0; j < SIZE - i; j++) {
      c[i] = c[i] + buf[j] * buf[j+i];
    }
  }

  let d = 0; while (c[d] > c[d+1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i = d; i < SIZE; i++) {
    if (c[i] > maxval) {
      maxval = c[i]; maxpos = i;
    }
  }
  let T0 = maxpos;
  return sampleRate / T0;
}

function pickRandomNote(excludeNote) {
  let available = noteStrings.filter(n => n !== excludeNote);
  return available[Math.floor(Math.random() * available.length)];
}

function updatePitch() {
  analyser.getFloatTimeDomainData(buf);
  const ac = autoCorrelate(buf, audioCtx.sampleRate);
  if (ac === -1) {
    detectedNoteElem.textContent = "—";
    return requestAnimationFrame(updatePitch);
  }

  const pitch = ac;
  const note = noteFromPitch(pitch);
  const noteName = noteStrings[note % 12];

  // 실제 수음된 음 표시
  detectedNoteElem.textContent = "수음된 음: " + noteName;

  // 랜덤 음 표시 (수음 음과 같으면 다시 뽑기)
  if (randomNoteElem.textContent === "—" || randomNoteElem.dataset.lockedNote === noteName) {
    let rnd = pickRandomNote(noteName);
    randomNoteElem.textContent = rnd;
    randomNoteElem.dataset.lockedNote = rnd;
  }

  requestAnimationFrame(updatePitch);
}

async function init() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  buf = new Float32Array(analyser.fftSize);

  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  sourceNode = audioCtx.createMediaStreamSource(stream);
  sourceNode.connect(analyser);

  updatePitch();
}

init();
</script>
</body>
</html>
