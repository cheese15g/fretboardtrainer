<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>무작위 음 맞추기</title>
  <style>
    :root {
      --bg: #0b0b0c;
      --fg: #f5f7fb;
      --muted: #a9b0bd;
      --accent: #8ab4ff;
      --ok: #16a34a;      /* 정답색 */
      --ng: #b91c1c;      /* 오답색 */
      --card: #15171a;
      --btn: #1f2329;
      --btnBorder: #2a2f36;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Malgun Gothic", Apple SD Gothic Neo, "Noto Sans KR", sans-serif;
      -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
    }
    .wrap {
      height: 100%; width: 100%; display: grid;
      grid-template-rows: auto 1fr auto; gap: 12px; padding: 16px;
    }
    header { display:flex; align-items:center; justify-content:space-between; }
    .title { font-weight: 700; letter-spacing: .3px; color: var(--muted); font-size: 14px; }
    .controls { display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .row { display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    select, button, .toggle {
      font-size: 14px; border-radius: 14px; padding: 10px 14px; border: 1px solid var(--btnBorder);
      background: var(--btn); color: var(--fg); cursor: pointer; outline: none;
    }
    select { appearance: none; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .toggle { display:inline-flex; align-items:center; gap:8px; user-select:none; }
    .toggle input { appearance:none; width:36px; height:22px; border-radius:999px; background:#31363d; position:relative; outline:none; border:1px solid var(--btnBorder); }
    .toggle input:after { content:""; position:absolute; top:1px; left:1px; width:18px; height:18px; background:#c7cbd2; border-radius:50%; transition:.2s; }
    .toggle input:checked { background:#2a353f; }
    .toggle input:checked:after { left:16px; background:#9ec1ff; }

    .stage {
      display:grid; place-items:center; background: var(--card);
      border-radius: 24px; border:1px solid #23272f; position:relative;
      min-height: 60vh; padding: 12px;
    }
    .big-note { font-size: clamp(64px, 18vw, 220px); font-weight: 800; line-height: 1; letter-spacing: -2px; }
    .status {
      position:absolute; top:12px; right:12px; font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--btnBorder); background: #121417; color: var(--muted);
    }
    .status.ok { background: rgba(22,163,74,.12); color: #7ee0a3; border-color: rgba(22,163,74,.35); }
    .status.ng { background: rgba(185,28,28,.12); color: #ff9f9f; border-color: rgba(185,28,28,.35); }

    .monitor { display:none; position:absolute; bottom:12px; left:12px; right:12px; }
    .monitor.show { display:block; }
    .card { background:#0f1216; border:1px solid #23272f; border-radius:16px; padding:10px 12px; color:#d4dae6; }
    .card .kvs { display:flex; flex-wrap:wrap; gap:14px; font-size:13px; }
    .kv { opacity:.9; }
    .kv .k { color:#95a1b2; margin-right:6px; }

    footer { display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
    .legend { color: var(--muted); font-size: 12px; }
    .grow { flex: 1 1 auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">무작위 음 맞추기 · 옥타브 무시 / 자연음(C D E F G A B)만 출제</div>
      <div class="controls">
        <div class="row">
          <label class="legend" for="device">입력장치</label>
          <select id="device"></select>
        </div>
        <button id="startBtn">입력 시작</button>
        <button id="stopBtn" disabled>정지</button>
        <button id="nextBtn" title="다음 문제(수동)">새 문제</button>
        <label class="toggle" title="누르면 앞으로 수음되는 음을 표시 / 다시 누르면 숨김">
          <input id="showMonitor" type="checkbox" />
          내가 치는 음 보기
        </label>
      </div>
    </header>

    <main class="stage" id="stage">
      <div id="status" class="status">대기 중</div>
      <div id="target" class="big-note">—</div>

      <div id="monitor" class="monitor">
        <div class="card">
          <div class="kvs">
            <span class="kv"><span class="k">현재 음:</span><span id="detNote">–</span></span>
            <span class="kv"><span class="k">주파수:</span><span id="detFreq">–</span> Hz</span>
            <span class="kv"><span class="k">RMS:</span><span id="detRms">–</span></span>
            <span class="kv"><span class="k">라그:</span><span id="detLag">–</span></span>
          </div>
        </div>
      </div>
    </main>

    <footer>
      <div class="legend">iOS/안드로이드/데스크탑 브라우저에서 동작. iOS는 반드시 버튼으로 시작해야 함(WebAudio 정책).</div>
      <div class="grow"></div>
      <div class="legend">정답 = 배경 가장자리 녹색 / 오답 = 붉은 테두리</div>
    </footer>
  </div>

  <script>
    // ====== 기본 설정 ======
    const NATURAL_NOTES = ["C","D","E","F","G","A","B"]; // 출제용
    const NATURAL_TO_SEMITONE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
    const ALL_NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

    let audioCtx = null;
    let mediaStream = null;
    let analyser = null;
    let rafId = null;
    let sampleRate = 48000;
    let currentTarget = null; // e.g., 'C'
    let lastTarget = null;
    const stage = document.getElementById('stage');
    const statusEl = document.getElementById('status');
    const targetEl = document.getElementById('target');
    const deviceSel = document.getElementById('device');
    const monitor = document.getElementById('monitor');
    const detNoteEl = document.getElementById('detNote');
    const detFreqEl = document.getElementById('detFreq');
    const detRmsEl = document.getElementById('detRms');
    const detLagEl = document.getElementById('detLag');

    // UI 버튼
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const nextBtn = document.getElementById('nextBtn');
    const showMonitor = document.getElementById('showMonitor');

    function pickRandomNatural() {
      let n;
      do { n = NATURAL_NOTES[Math.floor(Math.random()*NATURAL_NOTES.length)]; } while (n === lastTarget);
      lastTarget = n; return n;
    }

    function setTarget(note) {
      currentTarget = note;
      targetEl.textContent = note;
    }

    function setStatus(type, text) {
      statusEl.classList.remove('ok','ng');
      if (type === 'ok') statusEl.classList.add('ok');
      if (type === 'ng') statusEl.classList.add('ng');
      statusEl.textContent = text;
      stage.style.boxShadow = type === 'ok'
        ? '0 0 0 6px rgba(22,163,74,.35) inset'
        : type === 'ng'
          ? '0 0 0 6px rgba(185,28,28,.35) inset'
          : 'none';
    }

    // ====== 오디오 초기화 & 장치 ======
    async function listDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const inputs = devices.filter(d=>d.kind==='audioinput');
      deviceSel.innerHTML='';
      inputs.forEach((d,i)=>{
        const opt = document.createElement('option');
        opt.value = d.deviceId; opt.textContent = d.label || `입력장치 ${i+1}`;
        deviceSel.appendChild(opt);
      });
    }

    async function startAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      // 선택된 장치
      const deviceId = deviceSel.value || undefined;
      if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());

      mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          channelCount: { ideal: 1 },
          sampleRate: { ideal: 48000 },
          sampleSize: { ideal: 16 },
          echoCancellation: false, noiseSuppression: false, autoGainControl: false
        },
        video: false
      });

      const src = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048; // 타임도메인 버퍼 2048
      sampleRate = audioCtx.sampleRate;
      src.connect(analyser);

      loop();
      startBtn.disabled = true; stopBtn.disabled = false;
      setStatus('', '수음 중');
    }

    function stopAudio() {
      if (rafId) cancelAnimationFrame(rafId);
      if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
      mediaStream = null; analyser = null;
      startBtn.disabled = false; stopBtn.disabled = true;
      setStatus('', '대기 중');
    }

    // ====== 피치 검출 (자기상관 / ACF) ======
    const buf = new Float32Array(2048);
    const acf = new Float32Array(1024);

    function computeRMS(arr) {
      let s=0; for (let i=0;i<arr.length;i++){ const v=arr[i]; s+=v*v; }
      return Math.sqrt(s/arr.length);
    }

    function detectPitch() {
      if (!analyser) return { freq: null, rms: 0, lag: null };
      analyser.getFloatTimeDomainData(buf);

      // 에너지 체크 (무음/잡음 방지)
      const rms = computeRMS(buf);
      if (rms < 0.01) return { freq: null, rms, lag: null };

      // DC 오프셋 제거 및 정규화
      let mean=0; for (let i=0;i<buf.length;i++) mean+=buf[i]; mean/=buf.length;
      for (let i=0;i<buf.length;i++) buf[i]-=mean;

      // 자기상관
      const size = acf.length;
      for (let lag=0; lag<size; lag++) {
        let sum=0;
        for (let i=0;i<size;i++) sum += buf[i] * buf[i+lag];
        acf[lag] = sum;
      }

      // 첫번째 피크(0 제외) 탐색
      let peakIndex = -1; let peakValue = -Infinity;
      // 대략 80 Hz ~ 1kHz 범위(현악/보컬 기본음)로 제한
      const minLag = Math.floor(sampleRate/1000);  // 1kHz
      const maxLag = Math.min(Math.floor(sampleRate/80), size-1); // 80Hz
      for (let lag=minLag; lag<=maxLag; lag++) {
        const v = acf[lag];
        if (v>peakValue) { peakValue=v; peakIndex=lag; }
      }

      if (peakIndex<=0) return { freq:null, rms, lag:null };

      // 패러볼라 보간으로 더 정확한 피크 위치
      const i = peakIndex;
      const y1 = acf[i-1] || 0, y2 = acf[i], y3 = acf[i+1] || 0;
      const denom = (y1 - 2*y2 + y3);
      let shift = 0;
      if (denom !== 0) shift = 0.5 * (y1 - y3) / denom; // -0.5..+0.5
      const trueLag = i + shift;

      const freq = sampleRate / trueLag;
      return { freq, rms, lag: trueLag };
    }

    // 주파수 → 음이름
    function freqToNoteName(f) {
      const midi = Math.round(69 + 12*Math.log2(f/440));
      const name = ALL_NOTE_NAMES[(midi % 12 + 12) % 12];
      const octave = Math.floor(midi/12) - 1;
      return { name, octave, midi };
    }

    // ====== 메인 루프 ======
    let smoothFreq = null; // 간단 저역통과로 안정화
    function loop() {
      rafId = requestAnimationFrame(loop);
      const { freq, rms, lag } = detectPitch();

      // 스무딩
      let shownFreq = null;
      if (freq && rms > 0.01 && freq >= 60 && freq <= 1200) {
        smoothFreq = smoothFreq ? (smoothFreq*0.75 + freq*0.25) : freq;
        shownFreq = smoothFreq;
      } else {
        smoothFreq = null;
      }

      if (shownFreq) {
        const note = freqToNoteName(shownFreq);
        const detectedNatural = note.name.replace('♯','#').replace('♭','b').replace(/[#b]$/,''); // 자연음 글자만 추출
        const correct = currentTarget && (detectedNatural === currentTarget);

        detNoteEl.textContent = `${note.name}${note.octave}`;
        detFreqEl.textContent = shownFreq.toFixed(2);
        detRmsEl.textContent = rms.toFixed(3);
        detLagEl.textContent = lag ? lag.toFixed(1) : '–';

        // 상태/테두리 색상
        if (currentTarget) setStatus(correct ? 'ok' : 'ng', correct ? '정답' : '오답');

        // 정답이면 자동으로 다음 문제
        if (correct) {
          // 짧은 지연 후 새로운 문제
          const keep = currentTarget; // 현재 표시가 바로 바뀌지 않도록 캡처
          currentTarget = null; // 중복 처리 방지
          setTimeout(()=>{ setTarget(pickRandomNatural()); setStatus('', '수음 중'); }, 500);
        }
      } else {
        detFreqEl.textContent = '–';
        detNoteEl.textContent = '–';
        detRmsEl.textContent = '–';
        detLagEl.textContent = '–';
        if (currentTarget) setStatus('ng','오답');
      }

      // 모니터 표시 토글
      monitor.classList.toggle('show', showMonitor.checked);
    }

    // ====== 이벤트 바인딩 ======
    startBtn.addEventListener('click', async () => {
      try {
        await startAudio();
      } catch (e) {
        alert('마이크/오디오 접근 실패: ' + e.message);
      }
    });
    stopBtn.addEventListener('click', stopAudio);
    nextBtn.addEventListener('click', () => setTarget(pickRandomNatural()));
    showMonitor.addEventListener('change', () => { /* 표시만 토글 (루프에서 반영) */ });

    deviceSel.addEventListener('change', async ()=>{
      if (mediaStream) await startAudio();
    });

    // 초기화: 권한 안내 & 장치 목록
    (async () => {
      try {
        // 장치 레이블 표시를 위해 한 번 권한 요청 (사용자가 거절해도 목록은 나올 수 있음)
        await navigator.mediaDevices.getUserMedia({ audio:true, video:false }).then(s=>s.getTracks().forEach(t=>t.stop())).catch(()=>{});
      } finally {
        await listDevices();
        setTarget(pickRandomNatural());
      }
    })();
  </script>
</body>
</html>
