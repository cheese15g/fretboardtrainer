<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Note Trainer</title>
  <style>
    body {
      background: white;
      color: black;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    #note-display {
      font-size: 8em;
      margin: 50px 0;
    }
    .controls {
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 1em;
    }
    #your-note {
      margin-top: 20px;
      font-size: 2em;
      color: gray;
    }
  </style>
</head>
<body>
  <div id="note-display">C</div>
  
  <div class="controls">
    <button id="toggle-accidentals">Accidentals: Off</button>
    <button id="toggle-show-note">Show Your Note: Off</button>
  </div>
  
  <div id="your-note"></div>

  <script>
    const naturalNotes = ["C", "D", "E", "F", "G", "A", "B"];
    const accidentalNotes = [
      "C#", "D♭", "D#", "E♭", "F#", "G♭", "G#", "A♭", "A#", "B♭"
    ];
    let useAccidentals = false;
    let showYourNote = false;
    let targetNote = "";

    const noteDisplay = document.getElementById("note-display");
    const yourNoteDisplay = document.getElementById("your-note");
    const toggleAccidentals = document.getElementById("toggle-accidentals");
    const toggleShowNote = document.getElementById("toggle-show-note");

    function getRandomNote() {
      let pool = [...naturalNotes];
      if (useAccidentals) pool = pool.concat(accidentalNotes);
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function newNote() {
      targetNote = getRandomNote();
      noteDisplay.textContent = targetNote;
      document.body.style.background = "white";
    }

    toggleAccidentals.addEventListener("click", () => {
      useAccidentals = !useAccidentals;
      toggleAccidentals.textContent = "Accidentals: " + (useAccidentals ? "On" : "Off");
      newNote();
    });

    toggleShowNote.addEventListener("click", () => {
      showYourNote = !showYourNote;
      toggleShowNote.textContent = "Show Your Note: " + (showYourNote ? "On" : "Off");
      if (!showYourNote) yourNoteDisplay.textContent = "";
    });

    function noteFromPitch(freq) {
      const noteStrings = [
        "C", "C#", "D", "D#", "E", "F",
        "F#", "G", "G#", "A", "A#", "B"
      ];
      const A4 = 440;
      const semitone = 69;
      const midi = Math.round(12 * Math.log2(freq / A4) + semitone);
      return noteStrings[midi % 12];
    }

    async function initAudio() {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(stream);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);
      const bufferLength = analyser.fftSize;
      const buffer = new Float32Array(bufferLength);

      function autoCorrelate(buf, sampleRate) {
        let SIZE = buf.length;
        let rms = 0;
        for (let i = 0; i < SIZE; i++) {
          let val = buf[i];
          rms += val * val;
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) return -1; // sensitivity adjustment

        let r1 = 0, r2 = SIZE - 1, thres = 0.2;
        for (let i = 0; i < SIZE / 2; i++) {
          if (Math.abs(buf[i]) < thres) { r1 = i; break; }
        }
        for (let i = 1; i < SIZE / 2; i++) {
          if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
        }

        buf = buf.slice(r1, r2);
        SIZE = buf.length;
        let c = new Array(SIZE).fill(0);
        for (let i = 0; i < SIZE; i++)
          for (let j = 0; j < SIZE - i; j++)
            c[i] = c[i] + buf[j] * buf[j + i];

        let d = 0;
        while (c[d] > c[d + 1]) d++;
        let maxval = -1, maxpos = -1;
        for (let i = d; i < SIZE; i++) {
          if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
        }
        let T0 = maxpos;

        return sampleRate / T0;
      }

      function update() {
        analyser.getFloatTimeDomainData(buffer);
        const pitch = autoCorrelate(buffer, audioCtx.sampleRate);
        if (pitch !== -1) {
          const note = noteFromPitch(pitch);
          if (showYourNote) yourNoteDisplay.textContent = "You: " + note;
          if (note === targetNote || 
              (note + "♭" === targetNote) || 
              (note + "#" === targetNote)) {
            document.body.style.background = "#b2ffb2";
            newNote();
          } else {
            document.body.style.background = "#ffb2b2";
          }
        }
        requestAnimationFrame(update);
      }
      update();
    }

    newNote();
    initAudio();
  </script>
</body>
</html>
